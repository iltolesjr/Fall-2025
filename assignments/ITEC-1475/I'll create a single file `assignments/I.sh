I'll create a single file `assignments/ITEC-1475/catchup-one-session.md` that contains a concise plan and a copy-pasteable wrapper script (`run-catchup.sh`) which SSHs to your lab VMs and runs the necessary commands for the prior assignments in order (hostname change, create users/SSH, NTP/DNS checks, software managers, and NFS). The script prompts for targets, user, key path, and supports a dry-run. I'll add usage instructions for PowerShell on Windows and for bash/WSL.{"filePath":"vscode-vfs://github%2B7b2276223a312c22726566223a7b2274797065223a332c226964223a223231227d7d/iltolesjr/Fall-2025/assignments/ITEC-1475/catchup-one-session.md","content":"# Catch-up: Run past assignments in one terminal session\n\nGoal\n- Run through the core previous labs (Week 2 hostname, Week 3 users/SSH, Week 4 NTP/DNS checks, Week 6 software managers, Lab 9 NFS) from a single terminal session by SSH-ing into your lab VMs and executing the required command blocks.\n\nHow this file is organized\n- Short checklist of what will be done.\n- One wrapper script you can copy/paste (`run-catchup.sh`) that calls the per-lab command sets on the target host(s).\n- Per-lab command blocks (what will be executed remotely).\n- Usage examples for PowerShell (Windows) and bash/WSL.\n\nImportant safety notes\n- This script does not store passwords. Prefer SSH key authentication and pass a private key path with `-i` when prompted.\n- Always run in `--dry-run` mode first to preview the exact SSH commands that will be executed.\n- Backups: the script will back up `/etc/hosts` before changing hostnames and will not remove files.\n- The script assumes target hosts are Debian/Ubuntu (apt) or Rocky (dnf) depending on the commands used; commands are conservative and use checks before running distro-specific steps.\n\nChecklist (order executed)\n1. Verify targets and connectivity (ping, ssh reachability)\n2. Week 2 — Change hostname (update hostnamectl and /etc/hosts)\n3. Week 3 — Create user, configure SSH (authorized_keys)\n4. Week 4 — NTP and DNS checks (check systemd-timesyncd/chrony and /etc/resolv.conf)\n5. Week 6 — Install/verify snap/flatpak/docker (software managers)\n6. Lab 9 — NFS server setup and client mount test (if server/client available)\n\n---\n\nRun-catchup wrapper script (copy this into a file named `run-catchup.sh` on your local machine or in WSL)\n\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\nprint_usage(){\n  cat <<EOF\nUsage: $0 --targets \"ip1,ip2\" --user ubuntu [--key /path/to/id_rsa] [--dry-run] [--auto]\nOptions:\n  --targets   Comma-separated list of target IPs/FQDNs (required)\n  --user      SSH user to connect as (required)\n  --key       Path to private key file for ssh -i\n  --dry-run   Print commands instead of executing them\n  --auto      Auto-accept prompts (use with caution)\nEOF\n}\n\n# parse args\nTARGETS=\"\"\nSSH_USER=\"\"\nKEY_PATH=\"\"\nDRYRUN=0\nAUTO=0\nwhile [[ $# -gt 0 ]]; do\n  case \"$1\" in\n    --targets) TARGETS=\"$2\"; shift 2;;\n    --user) SSH_USER=\"$2\"; shift 2;;\n    --key) KEY_PATH=\"$2\"; shift 2;;\n    --dry-run) DRYRUN=1; shift;;\n    --auto) AUTO=1; shift;;\n    -h|--help) print_usage; exit 0;;\n    *) echo \"Unknown arg: $1\"; print_usage; exit 1;;\n  esac\ndone\n\nif [[ -z \"$TARGETS\" || -z \"$SSH_USER\" ]]; then\n  print_usage; exit 1\nfi\n\nIFS=',' read -r -a TARGET_ARR <<< \"$TARGETS\"\nSSH_OPTS=(\"-o\" \"StrictHostKeyChecking=no\" \"-o\" \"UserKnownHostsFile=/dev/null\")\nif [[ -n \"$KEY_PATH\" ]]; then\n  if [[ ! -f \"$KEY_PATH\" ]]; then echo \"Key not found: $KEY_PATH\"; exit 2; fi\n  SSH_OPTS+=(\"-i\" \"$KEY_PATH\")\nfi\n\n# helper to run or print remote commands\nrun_remote(){\n  local host=\"$1\"; shift\n  local cmd=\"$*\"\n  local sshcmd=(ssh \"${SSH_OPTS[@]}\" \"$SSH_USER@$host\" \"bash -lc '$cmd'\")\n  if [[ $DRYRUN -eq 1 ]]; then\n    echo \"[DRYRUN] ${sshcmd[*]}\"\n  else\n    echo \"=== Running on $host ===\"\n    \"${sshcmd[@]}\"\n  fi\n}\n\n# --- Per-lab command groups (single-quoted to preserve interpolation on remote host) ---\n# 1) Hostname change (Week 2)\nhostname_commands() {\n  local newhost=\"$1\"\n  cat <<'EOF'\nset -e\nsudo cp /etc/hosts /etc/hosts.bak || true\nsudo hostnamectl set-hostname REPLACE_NEWHOST\nVM_IP=$(hostname -I 2>/dev/null | awk '{print $1}')\nif [ -z \"$VM_IP\" ]; then VM_IP=$(ip -4 addr show scope global | grep -oP '(?<=inet\\s)\\d+(?:\\.\\d+){3}' | head -n1); fi\nif [ -z \"$VM_IP\" ]; then VM_IP=127.0.1.1; fi\n# Append mapping if not already present\ngrep -q \"\\b$NEWHOST\\b\" /etc/hosts || echo \"$VM_IP $NEWHOST\" | sudo tee -a /etc/hosts\nhostnamectl\ncat /etc/hosts\nEOF\n}\n\n# 2) Create user & SSH (Week 3)\nuser_ssh_commands() {\n  local newuser=\"$1\"\n  cat <<'EOF'\nset -e\n# create a sudo user if not exists\nif ! id -u REPLACE_USER >/dev/null 2>&1; then\n  sudo adduser --disabled-password --gecos \"\" REPLACE_USER || true\n  echo \"REPLACE_USER:PleaseChange\" | sudo chpasswd || true\n  sudo usermod -aG sudo REPLACE_USER || true\nfi\nsudo mkdir -p /home/REPLACE_USER/.ssh\nsudo chmod 700 /home/REPLACE_USER/.ssh\n# leave a placeholder for authorized_keys; user should copy key manually or via script\necho \"# add your public key to /home/REPLACE_USER/.ssh/authorized_keys\" | sudo tee -a /home/REPLACE_USER/.ssh/authorized_keys\nsudo chown -R REPLACE_USER:REPLACE_USER /home/REPLACE_USER/.ssh\nsudo chmod 600 /home/REPLACE_USER/.ssh/authorized_keys\nid REPLACE_USER\nsudo tail -n 20 /etc/ssh/sshd_config || true\nsudo systemctl reload sshd || true\nEOF\n}\n\n# 3) NTP/DNS check (Week 4)\nntp_dns_commands() {\n  cat <<'EOF'\nset -e\necho \"-- timedatectl --\"; timedatectl\nif command -v chronyc >/dev/null 2>&1; then echo \"-- chronyc sources --\"; chronyc sources || true; fi\necho \"-- resolv.conf --\"; cat /etc/resolv.conf || true\nEOF\n}\n\n# 4) Software managers (Week 6) - apt conservative\nsoftware_managers_commands() {\n  cat <<'EOF'\nset -e\n# Debian/Ubuntu path\nif [ -f /etc/debian_version ]; then\n  sudo apt-get update -y\n  sudo apt-get install -y snapd flatpak apt-transport-https ca-certificates curl\n  sudo systemctl enable --now snapd.socket || true\n  sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || true\n  mkdir -p ~/software-managers-lab && cd ~/software-managers-lab\n  echo \"lab test\" > testfile.txt; tar -czf software-managers-test.tgz testfile.txt\nfi\n# Rocky/CentOS path\nif [ -f /etc/redhat-release ]; then\n  sudo dnf install -y snapd flatpak || true\n  sudo systemctl enable --now snapd.socket || true\nfi\nEOF\n}\n\n# 5) NFS setup (server side minimal) and client mount check\nnfs_server_commands() {\n  cat <<'EOF'\nset -e\nif [ -f /etc/redhat-release ]; then\n  sudo dnf install -y nfs-utils || true\n  sudo mkdir -p /var/nfs/shared\n  sudo chown nobody:nobody /var/nfs/shared || true\n  echo \"Hi from server\" | sudo tee /var/nfs/shared/from_server\n  grep -q \"/var/nfs/shared\" /etc/exports || echo \"/var/nfs/shared 10.14.75.0/24(rw,sync,no_subtree_check)\" | sudo tee -a /etc/exports\n  sudo systemctl enable --now nfs-server rpcbind || true\n  sudo exportfs -v || true\nfi\nif [ -f /etc/debian_version ]; then\n  sudo apt-get update -y\n  sudo apt-get install -y nfs-kernel-server || true\n  sudo mkdir -p /srv/nfs_share\n  sudo chown nobody:nogroup /srv/nfs_share || true\n  echo \"Hi from server\" | sudo tee /srv/nfs_share/from_server\n  grep -q \"/srv/nfs_share\" /etc/exports || echo \"/srv/nfs_share 10.14.75.0/24(rw,sync,no_subtree_check)\" | sudo tee -a /etc/exports\n  sudo exportfs -a || true\n  sudo systemctl enable --now nfs-kernel-server || true\n  sudo exportfs -v || true\nfi\nEOF\n}\n\nnfs_client_commands() {\n  local server_ip=\"$1\"\n  cat <<'EOF'\nset -e\nif [ -f /etc/debian_version ]; then\n  sudo apt-get update -y\n  sudo apt-get install -y nfs-common || true\n  sudo mkdir -p /mnt/rocky_share\n  sudo mount -t nfs SERVER_IP:/var/nfs/shared /mnt/rocky_share 2>/dev/null || sudo mount -t nfs SERVER_IP:/srv/nfs_share /mnt/rocky_share || true\n  mount | grep nfs || true\n  df -h /mnt/rocky_share || true\n  echo \"lab test from $(hostname)\" | sudo tee /mnt/rocky_share/testfile.txt || true\n  sudo cat /mnt/rocky_share/testfile.txt || true\nfi\nEOF\n}\n\n# --- Execution plan: for each target, run the selected sequence ---\nfor host in \"${TARGET_ARR[@]}\"; do\n  echo \"\\n--- CHECK connectivity to $host ---\"\n  if [[ $DRYRUN -eq 1 ]]; then\n    echo \"[DRYRUN] ssh ${SSH_USER}@${host} ${SSH_OPTS[*]} 'echo connected'\"\n  else\n    ssh \"${SSH_OPTS[@]}\" \"${SSH_USER}@${host}\" 'echo connected' || { echo \"Cannot SSH $host\"; continue; }\n  fi\n\n  # 1) Hostname - prompt for new hostname per-host unless HostnameMap provided\n  read -p \"New hostname to set on $host (leave blank to skip): \" NH\n  if [[ -n \"$NH\" ]]; then\n    # inject host-specific new hostname into command\n    CMD=$(hostname_commands \"$NH\" | sed \"s/REPLACE_NEWHOST/$NH/g\" )\n    if [[ $DRYRUN -eq 1 ]]; then echo \"[DRYRUN] on $host: $CMD\"; else run_remote \"$host\" \"$CMD\"; fi\n  fi\n\n  # 2) Create user & SSH\n  read -p \"Create admin user on $host? Enter username or leave blank to skip: \" NU\n  if [[ -n \"$NU\" ]]; then\n    CMD=$(user_ssh_commands \"$NU\" | sed \"s/REPLACE_USER/$NU/g\")\n    if [[ $DRYRUN -eq 1 ]]; then echo \"[DRYRUN] on $host: $CMD\"; else run_remote \"$host\" \"$CMD\"; fi\n  fi\n\n  # 3) NTP/DNS check\n  CMD=$(ntp_dns_commands)\n  if [[ $DRYRUN -eq 1 ]]; then echo \"[DRYRUN] on $host: $CMD\"; else run_remote \"$host\" \"$CMD\"; fi\n\n  # 4) Software managers\n  read -p \"Run software managers installs on $host? (y/N) \" SM\n  if [[ \"$SM\" =~ ^[Yy] ]]; then\n    CMD=$(software_managers_commands)\n    if [[ $DRYRUN -eq 1 ]]; then echo \"[DRYRUN] on $host: $CMD\"; else run_remote \"$host\" \"$CMD\"; fi\n  fi\n\n  # 5) NFS server setup (optional)\n  read -p \"Configure this host as NFS server? (y/N) \" NS\n  if [[ \"$NS\" =~ ^[Yy] ]]; then\n    CMD=$(nfs_server_commands)\n    if [[ $DRYRUN -eq 1 ]]; then echo \"[DRYRUN] on $host: $CMD\"; else run_remote \"$host\" \"$CMD\"; fi\n  fi\n\n  # 6) If this is a client and a server IP provided, try client mount\n  read -p \"If mounting from a server, enter server IP (or leave blank): \" SIP\n  if [[ -n \"$SIP\" ]]; then\n    CMD=$(nfs_client_commands \"$SIP\" | sed \"s/SERVER_IP/$SIP/g\")\n    if [[ $DRYRUN -eq 1 ]]; then echo \"[DRYRUN] on $host: $CMD\"; else run_remote \"$host\" \"$CMD\"; fi\n  fi\n\ndone\n\necho \"\\nAll done. If you used --dry-run, review the prints above and rerun without --dry-run to execute.\" \n```\n\nNotes about the wrapper\n- The script is intentionally interactive for two reasons: (1) it prevents accidental mass changes, and (2) the instructor expects one-off confirmations for destructive actions.\n- If you want fully non-interactive runs, add `--auto` and adjust prompts accordingly (I can extend the script if you want headless execution).\n\nPer-lab command highlights (for copying into a terminal directly)\n\n- Week 2 (change hostname):\n```bash\nsudo hostnamectl set-hostname <new-hostname>\nsudo cp /etc/hosts /etc/hosts.bak\nVM_IP=$(hostname -I | awk '{print $1}')\necho \"$VM_IP <new-hostname>\" | sudo tee -a /etc/hosts\n```\n\n- Week 3 (create user and authorized_keys):\n```bash\nsudo adduser --disabled-password --gecos \"\" <username>\nsudo usermod -aG sudo <username>\nsudo mkdir -p /home/<username>/.ssh\n# copy your public key to authorized_keys (on your machine):\n# scp -i ~/.ssh/id_rsa ~/.ssh/id_rsa.pub <user>@<host>:/tmp/key.pub\n# then on host:\nsudo tee -a /home/<username>/.ssh/authorized_keys < /tmp/key.pub\nsudo chown -R <username>:<username> /home/<username>/.ssh\nsudo chmod 700 /home/<username>/.ssh\nsudo chmod 600 /home/<username>/.ssh/authorized_keys\nsudo systemctl reload sshd || true\n```\n\n- Week 4 (NTP/DNS quick checks):\n```bash\ntimedatectl\ncat /etc/resolv.conf\nif command -v chronyc >/dev/null 2>&1; then chronyc sources; fi\n```\n\n- Week 6 (software managers):\n```bash\n# Debian/Ubuntu\nsudo apt-get update -y\nsudo apt-get install -y snapd flatpak apt-transport-https ca-certificates curl\nsudo systemctl enable --now snapd.socket || true\nsudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo || true\n\n# create artifact\necho \"lab test\" > testfile.txt; tar -czf software-managers-test.tgz testfile.txt\n```\n\n- Lab 9 (NFS): server & client quick commands\n```bash\n# Server (Rocky example)\nsudo dnf install -y nfs-utils\nsudo mkdir -p /var/nfs/shared\nsudo chown nobody:nobody /var/nfs/shared\necho \"Hi from Rocky\" | sudo tee /var/nfs/shared/from_rocky\necho \"/var/nfs/shared 10.14.75.0/24(rw,sync,no_subtree_check)\" | sudo tee -a /etc/exports\nsudo systemctl enable --now nfs-server rpcbind\nsudo exportfs -v\n\n# Client (Debian/Mint)\nsudo apt-get install -y nfs-common\nsudo mkdir -p /mnt/rocky_share\nsudo mount -t nfs <server-ip>:/var/nfs/shared /mnt/rocky_share\nls -l /mnt/rocky_share\n```\n\nHow to run (Windows PowerShell)\n```powershell\n# In PowerShell (Windows) using WSL or Git Bash is easiest. From PowerShell:\n# Using WSL bash\nwsl bash ./run-catchup.sh --targets \"10.14.75.236,10.14.75.255\" --user ubuntu --key \"/mnt/c/Users/you/.ssh/id_rsa\" --dry-run\n\n# Or run from Git Bash / WSL directly\nbash run-catchup.sh --targets \"10.14.75.236\" --user ubuntu --key \"/c/Users/you/.ssh/id_rsa\" --dry-run\n```\n\nFinal notes\n- Run with `--dry-run` first and confirm the printed commands.\n- After you run the script and capture screenshots, use the `lab9-filled-questions.md` or `lab9-submission-template.md` to prepare your final submission document.\n\nIf you want I can:\n- Produce a PowerShell version of this wrapper (for native pwsh runs), or\n- Make the wrapper fully non-interactive with a mapping file and confirm that you accept the risks. Let me know which.\n"},"message":"Create catchup-one-session file with script and instructions"}Done — I created `assignments/ITEC-1475/catchup-one-session.md`.

What I added
- A ready-to-copy wrapper script (`run-catchup.sh`) in the markdown that SSHs to your lab VMs and runs the per-lab command groups (Week 2 hostname, Week 3 users/SSH, Week 4 NTP/DNS checks, Week 6 software managers, Lab 9 NFS).
- Clear usage instructions for PowerShell/Windows and bash/WSL, plus safety notes and a recommended dry-run.
- Per-lab command blocks you can paste into a VM console directly if you prefer manual steps.

Next steps
- Run the wrapper in `--dry-run` to preview the SSH commands before executing.
- Tell me if you want a PowerShell-native wrapper, a headless non-interactive version, or a `.docx` version of the submission template — I can add any of those next.